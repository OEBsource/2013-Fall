plot(x,y, ylim=c(0,95), xlim=c(1,5), pch=20, ylab="Product of Ranges", xlab=" Geological Time Bin")#
#
segments(1.5, 32.74, 1.5, 50.02, lwd=2)#
segments(2.5, 27.03, 2.5, 38.81, lwd=2)#
segments(3.5, 51.25, 3.5, 79.55, lwd=2)#
segments(4.5, 28.19, 4.5, 43.18, lwd=2)#
#
lines(x,y, lwd=2)#
#
#legend("topright", "Uncorrected", bty="n", lty=1, , lwd=2,
x<-c(1.5, 2.5, 3.5, 4.5)#
y<-c(213.80, 121.72, 306.76, 115.95)#
#
quartz()#
plot(x,y, ylim=c(0,500), xlim=c(1,5), pch=20, ylab="Product of Variances", xlab=" Geological Time Bin")#
#
segments(1.5, 134.47, 1.5, 298.16, lwd=2)#
segments(2.5, 72.27, 2.5, 162.80, lwd=2)#
segments(3.5, 173.02, 3.5, 451.94, lwd=2)#
segments(4.5, 69.16, 4.5, 165.69, lwd=2)#
#
lines(x,y, lwd=2)#
#
#legend("topright", "Uncorrected", bty="n", lty=1, , lwd=2, pch=20, col="black")#
abline(v=2, lty=2, lwd=2)#
abline(v=3, lty=2, lwd=2)#
abline(v=4, lty=2, lwd=2)
plot(x,y, ylim=c(0,550), xlim=c(1,5), pch=20, ylab="Product of Variances", xlab=" Geological Time Bin")#
#
segments(1.5, 134.47, 1.5, 298.16, lwd=2)#
segments(2.5, 72.27, 2.5, 162.80, lwd=2)#
segments(3.5, 173.02, 3.5, 451.94, lwd=2)#
segments(4.5, 69.16, 4.5, 165.69, lwd=2)#
#
lines(x,y, lwd=2)#
#
#legend("topright", "Uncorrected", bty="n", lty=1, , lwd=2, pch=20, col="black")#
abline(v=2, lty=2, lwd=2)#
abline(v=3, lty=2, lwd=2)#
abline(v=4, lty=2, lwd=2)
Single Corrected Matrix version##
x<-c(1.5, 2.5, 3.5, 4.5)#
y<-c(641.84, 343.30, 704.11, 822.61)#
#
quartz()#
plot(x,y, ylim=c(0,1650), xlim=c(1,5), pch=20, ylab="Sum of Variances", xlab=" Geological Time Bin")#
#
segments(1.5, 314.30, 1.5, 1004.26, lwd=2)#
segments(2.5, 95.29, 2.5, 668.66, lwd=2)#
segments(3.5, 344.73, 3.5, 1133.12, lwd=2)#
segments(4.5, 258.27, 4.5, 1475.11, lwd=2)#
#
lines(x,y, lwd=2)#
#
#legend("topright", "Uncorrected", bty="n", lty=1, , lwd=2, pch=20, col="black")#
abline(v=2, lty=2, lwd=2)#
abline(v=3, lty=2, lwd=2)#
abline(v=4, lty=2, lwd=2)
x<-c(1.5, 2.5, 3.5, 4.5)#
y<-c(4092.47, 1458.89, 4188.04, 2359.40)#
#
quartz()#
plot(x,y, ylim=c(0,7250), xlim=c(1,5), pch=20, ylab="Sum of Variances", xlab=" Geological Time Bin")#
#
segments(1.5, 2823.93, 1.5, 5307.11, lwd=2)#
segments(2.5, 817.39, 2.5, 2083.73, lwd=2)#
segments(3.5, 2187.64, 3.5, 6330.78, lwd=2)#
segments(4.5, 1235.01, 4.5, 3593.87, lwd=2)#
#
lines(x,y, lwd=2)#
#
#legend("topright", "Uncorrected", bt
x<-c(1.5, 2.5, 3.5, 4.5)#
y<-c(3.23, 3.65, 5.35, 3.26)#
#
quartz()#
plot(x,y, ylim=c(0,10), xlim=c(1,5), pch=20, ylab="Product of Variances", xlab=" Geological Time Bin")#
#
segments(1.5, 1.79, 1.5, 4.50, lwd=2)#
segments(2.5, 1.96, 2.5, 5.32, lwd=2)#
segments(3.5, 3.05, 3.5, 7.87, lwd=2)#
segments(4.5, 1.84, 4.5, 4.70, lwd=2)#
#
lines(x,y, lwd=2)
x<-c(1.5, 2.5, 3.5, 4.5)#
y<-c(213.80, 121.72, 306.76, 115.95)#
#
quartz()#
plot(x,y, ylim=c(0,550), xlim=c(1,5), pch=20, ylab="Product of Variances", xlab=" Geological Time Bin")#
#
segments(1.5, 134.47, 1.5, 298.16, lwd=2)#
segments(2.5, 72.27, 2.5, 162.80, lwd=2)#
segments(3.5, 173.02, 3.5, 451.94, lwd=2)#
segments(4.5, 69.16, 4.5, 165.69, lwd=2)#
#
lines(x,y, lwd=2)#
#
#legend("topright", "Uncorrected", bty="n", lty=1, , lwd=2, pch=20, col="black")#
abline(v=2, lty=2, lwd=2)#
abline(v=3, lty=2, lwd=2)#
abline(v=4, lty=2, lwd=2)
x<-c(1.5, 2.5, 3.5, 4.5)#
y<-c(213.80, 121.72, 306.76, 115.95)#
#
quartz()#
plot(x,y, ylim=c(0,550), xlim=c(1,5), pch=20, ylab="Product of Variances", xlab=" Geological Time Bin")#
#
segments(1.5, 134.47, 1.5, 298.16, lwd=2)#
segments(2.5, 72.27, 2.5, 162.80, lwd=2)#
segments(3.5, 173.02, 3.5, 451.94, lwd=2)#
segments(4.5, 69.16, 4.5, 165.69, lwd=2)#
#
lines(x,y, lwd=2)#
#
#legend("topright", "Uncorrected", bty="n", lty=1, , lwd=2, pch=20, col="black")
Single Uncorrected Matrix Version##
x<-c(1.5, 2.5, 3.5, 4.5)#
y<-c(42.72, 34.65, 67.89, 37.54)#
#
quartz()#
plot(x,y, ylim=c(0,95), xlim=c(1,5), pch=20, ylab="Product of Ranges", xlab=" Geological Time Bin")#
#
segments(1.5, 32.74, 1.5, 50.02, lwd=2)#
segments(2.5, 27.03, 2.5, 38.81, lwd=2)#
segments(3.5, 51.25, 3.5, 79.55, lwd=2)#
segments(4.5, 28.19, 4.5, 43.18, lwd=2)#
#
lines(x,y, lwd=2)#
#
#legend("topright", "Uncorrected", bty="n", lty=1, , lwd=2, pch=20, col="black")
x<-c(1.5, 2.5, 3.5, 4.5)#
y<-c(5.84, 6.78, 10.33, 7.13)#
#
quartz()#
plot(x,y, ylim=c(0,15), xlim=c(1,5), pch=20, ylab="Product of Ranges", xlab=" Geological Time Bin")#
#
segments(1.5, 4.05, 1.5, 6.88, lwd=2)#
segments(2.5, 4.81, 2.5, 7.94, lwd=2)#
segments(3.5, 8.28, 3.5, 12.02, lwd=2)#
segments(4.5, 5.32, 4.5, 8.30, lwd=2)#
#
lines(x,y, lwd=2)#
#
#legend("topright", "Uncorrected", bty="n", lty=1, , lwd=2, pch=20, col="black")
x<-c(1.5, 2.5, 3.5, 4.5)#
y<-c(110.94, 109.50, 191.99, 151.79)#
#
quartz()#
plot(x,y, ylim=c(0,250), xlim=c(1,5), pch=20, ylab="Sum of Ranges", xlab=" Geological Time Bin")#
#
segments(1.5, 88.81, 1.5, 121.07, lwd=2)#
segments(2.5, 70.19, 2.5, 127.13, lwd=2)#
segments(3.5, 145.35, 3.5, 218.23, lwd=2)#
segments(4.5, 98.84, 4.5, 171.12, lwd=2)#
#
lines(x,y, lwd=2)#
#
#legend("topright", "Uncorrected", bty="n", lty=1, , lwd=2, pch=20, col="black")
x<-c(1.5, 2.5, 3.5, 4.5)#
y<-c(485.31, 360.77, 738.98, 441.65)#
#
quartz()#
plot(x,y, ylim=c(0,1000), xlim=c(1,5), pch=20, ylab="Sum of Ranges", xlab=" Geological Time Bin")#
#
segments(1.5, 389.80, 1.5, 552.27, lwd=2)#
segments(2.5, 279.28, 2.5, 402.23, lwd=2)#
segments(3.5, 541.54, 3.5, 859.52, lwd=2)#
segments(4.5, 328.97, 4.5, 496.09, lwd=2)#
#
lines(x,y, lwd=2)#
#
#legend("topright", "Uncorrected", bty="n", lty=1, , lwd=2, pch=20, col="black")
require(vegan)
citation(vegan)
citation("vegan")
??vegdist
?write.table
ANC<-read.csv("~/Desktop/test.csv", header=T)
str(ANC)
mod1<-aov(NotchAB~NotchAC*Species)
summary(mod1)
mod2<-aov(NotchAB~NotchAC+Species)#
#
summary(mod2)
anova(mod1, mod2)
mod1<-aov(NotchAB~NotchAC*Species, data=ANC)
summary(mod1)
mod2<-aov(NotchAB~NotchAC+Species, data=ANC)
summary(mod2)
anova(mod1, mod2)
Ktum<-ANC[ANC$Species=="Morganucodon",]
Mdon<-subset(ANC, Species=="Keuhneotherium")
re1<-lm(NotchAB~NotchAC, data=Mdon)
Mdon<-subset(ANC, Species=="Keuhneotherium")#
Ktum<-ANC[ANC$Species=="Morganucodon",]#
#
re1<-lm(NotchAB~NotchAC, data=Mdon); summary(reg1)#
#
re2<-lm(NotchAB~NotchAC, data=Ktum); summary(reg2)#
plot(NotchAB~NotchAC, data=ANC, type='n')#
points(Mdon$NotchAB, Mdon$NotchAC, pch=20)#
points(Ktum$NotchAB, Ktum$NotchAC, pch=1)#
#
abline(reg1, lty=1)#
abline(reg2, lty=2)#
legend("bottomright", c("Morganucodon","Keuhneotherium"), lty=c(1,2), pch=c(20))
reg1<-lm(NotchAB~NotchAC, data=Mdon); summary(reg1)#
#
reg2<-lm(NotchAB~NotchAC, data=Ktum); summary(reg2)#
plot(NotchAB~NotchAC, data=ANC, type='n')#
points(Mdon$NotchAB, Mdon$NotchAC, pch=20)#
points(Ktum$NotchAB, Ktum$NotchAC, pch=1)#
#
abline(reg1, lty=1)#
abline(reg2, lty=2)#
legend("bottomright", c("Morganucodon","Keuhneotherium"), lty=c(1,2), pch=c(20))
require(vegan)
citation(vegan)
citation("vegan")
require(abind); require(vegan)
citation(abind); citation(vegan)
citation(abind)
citation("abind")
citation("vegan")
require(reshape)
citation"reshape
citation("reshape")
citation("vegan")
citation("abind")
require(vegan)
?vegdist
citation()
?quantile
x<-c(0,1,2,3,4,5)
y<-c(2,3,4,5,6)
fit<-(x~y)
plot(x~y)
x<-c(1,2,3,4,5)
x<-c(1,2,3,4,5)#
y<-c(2,3,4,5,6)#
#
fit<-(x~y)#
#
plot(x~y)
fit<-(x,y)
plot(x,y)
abline(fit)
x<-c(1,2,3,4,5)#
y<-c(2,3,4,5,6)#
#
fit<-(y~x)#
#
plot(x,y)#
#
abline(fit)
x<-c(1,2,3,4,5)#
y<-c(2,3,4,5,6)#
#
fit<-(y~x)
plot(x,y)
abline(fit)
plot(y,x)
abline(fit)
x<-c(1,2,3,4,5)#
y<-c(2,3,4,5,6)#
#
fit<-(y~x)#
#
plot(x,y)#
#
abline(fit)
fit
fit<-lm(y~x)#
#
plot(x,y)#
#
abline(fit)
quantile(c(x,y), probs=c(0.025,0.0975))
lines(quantile(c(x,y), probs=c(0.025,0.0975)))
quantile(c(x,y), probs=c(0.025,0.975))
?predict
predict(fit)
x<-c(1,2,3,4,5)#
y<-c(3,6,8,9,10)#
#
fit<-lm(y~x)#
#
predict(fit)
predict(fit, interval='confidence')
poop<-predict(fit, interval='confidence')
plot(x,y)
lines(x,poop[,2])
plot(x,y, xlim=c(0,10), ylim=c(0,10))#
#
lines(x,poop[,2])
lines(x,poop[,3])
lines(x, poop[,1])
plot(x,y, xlim=c(0,10), ylim=c(0,10))#
#
lines(x,poop[,2], lty=2)#
lines(x,poop[,3], lty=2)#
lines(x, poop[,1])
x#
poop[,2]
str(poop[,2])
str[,x]
str(x)
x#
poop[,2][1]
poop[,2]
as.vector(poop[,2])
str(poop)
class(poop)
as.data.frame(poop)
class(poop)
poop1<-as.data.frame(poop)
class(poop1)
poop1
poop1$newcol<-x
poop1
require(gclus)#
require(vegan)
Teeth<-read.csv("~/Desktop/Teeth1.csv", header=T)#
Ktherium<-Teeth[Teeth$Species=="Keuhneotherium",]#
Mucodon<-Teeth[Teeth$Species=="Morganucodon",]
Ktherium
my.abs <-abs(cor(Ktherium[,4:11]))#
my.colors<-dmat.color(my.abs)#
cpairs(Ktherium[,3:11], panel.colors=my.colors, gap=.5)
cpairs(Ktherium[,4:11], panel.colors=my.colors, gap=.5)
plot(Ktherium[,4], Ktherium[,9])
Ktherium
Teeth<-read.csv("~/Desktop/Teeth1.csv", header=T)#
Ktherium<-Teeth[Teeth$Species=="Keuhneotherium",]#
Mucodon<-Teeth[Teeth$Species=="Morganucodon",]
my.abs <-abs(cor(Ktherium[,4:11]))#
my.colors<-dmat.color(my.abs)#
cpairs(Ktherium[,4:11], panel.colors=my.colors, gap=.5)
plot(Ktherium[,4], Ktherium[,9])
set.seed(101)
x <- 0:100#
y <- 2*x + rnorm(101, 0, 10)
plot(x, y)
mod1 <- lm(y ~ x)#
yHat <- fitted(mod1)
errors <- resid(mod1)
boot <- function(n = 10000){#
 b1 <- numeric(n)#
 b1[1] <- coef(mod1)[2]#
 for(i in 2:n){#
 residBoot <- sample(errors, replace=F)#
 yBoot <- yHat + residBoot#
 modBoot <- lm(yBoot ~ x)#
 b1[i] <- coef(modBoot)[2]#
 }#
 return(b1)#
}
system.time( bootB1 <- boot() )
yHat
errors
?lm.fit
boot <- function(n = 10000){#
 b1 <- numeric(n)#
 b1[1] <- coef(mod1)[2]#
 for(i in 2:n){#
 residBoot <- sample(errors, replace=F)#
 yBoot <- yHat + residBoot#
 modBoot <- lm.fit(yBoot ~ x)#
 b1[i] <- coef(modBoot)[2]#
 }#
 return(b1)#
}#
# Run the bootstrapping function#
system.time( bootB1 <- boot() )#
mean(bootB1)
boot <- function(n = 10000){#
 b1 <- numeric(n)#
 b1[1] <- coef(mod1)[2]#
 for(i in 2:n){#
 residBoot <- sample(errors, replace=F)#
 yBoot <- yHat + residBoot#
 modBoot <- lm(yBoot ~ x)#
 b1[i] <- coef(modBoot)[2]#
 }#
 return(b1)#
}#
# Run the bootstrapping function#
system.time( bootB1 <- boot() )#
mean(bootB1)
install.packages("surface")
require(surface)
data(surfaceDemo)
tree<-surfaceDemo$tree
dat<-surfaceDemo$sim$dat
tree<-nameNodes(tree)
olist<-convertTreeData(tree,dat)
otree<-olist[[1]]; odata<-olist[[2]]
fwd<-surfaceForward(otree, odata, aic_threshold = 0, exclude = 0, verbose = FALSE, plotaic = FALSE)
k<-length(fwd)
fsum<-surfaceSummary(fwd) ;names(fsum)
bwd<-surfaceBackward(otree, odata, starting_model = fwd[[k]], aic_threshold = 0, only_best = FALSE, verbose = FALSE, plotaic = FALSE) ; bsum<-surfaceSummary(bwd) ; kk<-length(bwd)
surfaceTreePlot(tree, bwd[[kk]], labelshifts = T)
par(mfrow=c(1,2), mai=c(0.8,0.8,0.2,0.2)) ; surfaceTraitPlot(dat, bwd[[kk]], whattraits = c(1,2)) ; surfaceTraitPlot(dat, bwd[[kk]], whattraits = c(3,2))
surfaceTreePlot(tree, bwd[[kk]], labelshifts = F)
dat
olist
otree
montecarloPi <- function(trials) {#
  count = 0#
  for(i in 1:trials) {#
    if((runif(1,0,1)^2 + runif(1,0,1)^2)<1) {#
      count = count + 1#
    }#
  }#
  return((count*4)/trials)#
}
montecarloPi(10)
montecarloPi(10000)
montecarloPi(10000000)
iDemandPi<-function(n=100){#
#Two runs will give you your x and y coordinate position#
randomX<-runif(n=n, min=-1, max=1)#
randomY<-runif(n=n, min=-1, max=1)#
#
#To get ourt circle part, x^2+y^2=1, and also values less than one will be within the circle#
insideCircle<-randomX^2+randomY^2<=1#
#Want to get # points in circle/# points in square * 4 (area of square)#
#Divide by n (all numbers) as all numbers will be somewhere within the square.#
#R reads TRUE and FALSE statements as 1 and 0.#
myPi=4*(sum(insideCircle)/n)#
#
#Now index by the logical statement.#
plot(x=randomX[insideCircle], y=randomY[insideCircle], pch=19)#
return(myPi)#
}
iDemandPi(10000)
randomX<-runif(n=10, min=-1, max=1)#
randomY<-runif(n=10, min=-1, max=1)
randomX
randomY
insideCircle<-randomX^2+randomY^2<=1
insideCircle
myPi=4*(sum(insideCircle)/10)
myPi
sum(insideCircle)
4*(sum(insideCircle)/10)
sum(insideCircle)/10)
sum(insideCircle)/10
randomX<-runif(n=100, min=-1, max=1)#
randomY<-runif(n=100, min=-1, max=1)#
#
#To get ourt circle part, x^2+y^2=1, and also values less than one will be within the circle#
insideCircle<-randomX^2+randomY^2<=1#
#Want to get # points in circle/# points in square * 4 (area of square)#
#Divide by n (all numbers) as all numbers will be somewhere within the square.#
#R reads TRUE and FALSE statements as 1 and 0.#
myPi=4*(sum(insideCircle)/10)
randomX<-runif(n=100, min=-1, max=1)#
randomY<-runif(n=100, min=-1, max=1)#
#
#To get ourt circle part, x^2+y^2=1, and also values less than one will be within the circle#
insideCircle<-randomX^2+randomY^2<=1#
#Want to get # points in circle/# points in square * 4 (area of square)#
#Divide by n (all numbers) as all numbers will be somewhere within the square.#
#R reads TRUE and FALSE statements as 1 and 0.#
myPi=4*(sum(insideCircle)/100)
myPi
sum(insideCircle)
rnorm(1, 5, 2)
brownian< -function(n=1000,plot=T,fun=rnorm) {#
	x<-cumsum(fun(n))#
	y<-cumsum(fun(n))#
	plot(x,y,type="l")#
	}#
brownian(fun=rnorm)
brownian< -function(n=1000,plot=T,fun=rnorm) {#
	x<-cumsum(fun(n))#
	y<-cumsum(fun(n))#
	plot(x,y,type="l")#
	}
brownian<- function(n=1000,plot=T,fun=rnorm) {#
	x<-cumsum(fun(n))#
	y<-cumsum(fun(n))#
	plot(x,y,type="l")#
	}#
brownian(fun=rnorm)
brownian<- function(n=1000,plot=T,fun=rnorm,df=1) {#
	x<-cumsum(fun(n,df))#
	y<-cumsum(fun(n,df))#
	plot(x,y,type="l")#
	}#
brownian(fun=rt)
brownian<- function(n=1000,plot=T,fun=rnorm) {#
	x<-cumsum(fun(n))#
	y<-cumsum(fun(n))#
	plot(x,y,type="l")#
	}#
brownian(fun=rnorm)
brownian<- function(n=100,plot=T,fun=rnorm) {#
	x<-cumsum(fun(n))#
	y<-cumsum(fun(n))#
	plot(x,y,type="l")#
	}#
brownian(fun=rnorm)
brownian<- function(n=100,plot=T,fun=rnorm) {#
	x<-cumsum(fun(n))#
	y<-cumsum(fun(n))#
	plot(x,y,type="p")#
	}#
brownian(fun=rnorm)
brownian<- function(n=100,plot=T,fun=rnorm) {#
	x<-cumsum(fun(n))#
	y<-cumsum(fun(n))#
	plot(x,y,type="b")#
	}#
brownian(fun=rnorm)
maturity <- 15#
simulation.length <- 10001#
dt <-  maturity/(simulation.length-1)#
#
timeline <- seq(0,maturity, dt)#
#
S0<-1#
r<-0.05#
mu<-0.1#
mu0<-0.2#
sigma<-0.2#
sigma0<-0.375#
#
f <- g <- g0 <- h <- h0 <- rep(0, times=simulation.length)#
g0[1] <- h0[1] <- g[1] <-  h[1] <- S0#
#
for(i in 2:simulation.length){#
 f[i] <- f[i-1]+sqrt(dt)*rnorm(1)#
 g[i] <- g[1]*exp((mu-(sigma^2)/2)*(i-1)*dt+sigma*f[i])#
 g0[i] <- g0[1]*exp(mu*(i-1)*dt)#
 h[i] <- h[1]*exp((mu0-sigma0^2/2)*(i-1)*dt+sigma0*f[i])#
 h0[i] <- h0[1]*exp(mu0*(i-1)*dt)#
}#
#
o_range <- range(f,g,g0,h,h0)#
#
plot(timeline,f, ylim=o_range, type="l", col="coral1")#
lines(timeline,g0, col="chartreuse3")#
lines(timeline,g, col="chartreuse2")#
lines(timeline,h, col="deepskyblue1")#
lines(timeline,h0, col="deepskyblue3")#
#
title(main="Geometric Brownian Motion trajectories", col.main="red", font.main=4)#
legend(1, o_range[2], c("mu = 0.2,  sigma = 0.375","mu = 0.1,  sigma = 0.2","Brownian motion"), cex=0.8, #
   col=c("deepskyblue1","chartreuse2","coral1"), pch=1, lty=1);
maturity <- 15#
simulation.length <- 10001#
dt <-  maturity/(simulation.length-1)#
#
timeline <- seq(0,maturity, dt)#
#
S0<-1#
r<-0.05#
mu<-0.1#
mu0<-0.2#
sigma<-0.8#
sigma0<-0.375#
#
f <- g <- g0 <- h <- h0 <- rep(0, times=simulation.length)#
g0[1] <- h0[1] <- g[1] <-  h[1] <- S0#
#
for(i in 2:simulation.length){#
 f[i] <- f[i-1]+sqrt(dt)*rnorm(1)#
 g[i] <- g[1]*exp((mu-(sigma^2)/2)*(i-1)*dt+sigma*f[i])#
 g0[i] <- g0[1]*exp(mu*(i-1)*dt)#
 h[i] <- h[1]*exp((mu0-sigma0^2/2)*(i-1)*dt+sigma0*f[i])#
 h0[i] <- h0[1]*exp(mu0*(i-1)*dt)#
}#
#
o_range <- range(f,g,g0,h,h0)#
#
plot(timeline,f, ylim=o_range, type="l", col="coral1")#
lines(timeline,g0, col="chartreuse3")#
lines(timeline,g, col="chartreuse2")#
lines(timeline,h, col="deepskyblue1")#
lines(timeline,h0, col="deepskyblue3")#
#
title(main="Geometric Brownian Motion trajectories", col.main="red", font.main=4)#
legend(1, o_range[2], c("mu = 0.2,  sigma = 0.375","mu = 0.1,  sigma = 0.2","Brownian motion"), cex=0.8, #
   col=c("deepskyblue1","chartreuse2","coral1"), pch=1, lty=1);
maturity <- 15#
simulation.length <- 10001#
dt <-  maturity/(simulation.length-1)#
#
timeline <- seq(0,maturity, dt)#
#
S0<-1#
r<-0.05#
mu<-0.1#
mu0<-0.2#
sigma<-0.8#
sigma0<-0.8#
#
f <- g <- g0 <- h <- h0 <- rep(0, times=simulation.length)#
g0[1] <- h0[1] <- g[1] <-  h[1] <- S0#
#
for(i in 2:simulation.length){#
 f[i] <- f[i-1]+sqrt(dt)*rnorm(1)#
 g[i] <- g[1]*exp((mu-(sigma^2)/2)*(i-1)*dt+sigma*f[i])#
 g0[i] <- g0[1]*exp(mu*(i-1)*dt)#
 h[i] <- h[1]*exp((mu0-sigma0^2/2)*(i-1)*dt+sigma0*f[i])#
 h0[i] <- h0[1]*exp(mu0*(i-1)*dt)#
}#
#
o_range <- range(f,g,g0,h,h0)#
#
plot(timeline,f, ylim=o_range, type="l", col="coral1")#
lines(timeline,g0, col="chartreuse3")#
lines(timeline,g, col="chartreuse2")#
lines(timeline,h, col="deepskyblue1")#
lines(timeline,h0, col="deepskyblue3")#
#
title(main="Geometric Brownian Motion trajectories", col.main="red", font.main=4)#
legend(1, o_range[2], c("mu = 0.2,  sigma = 0.375","mu = 0.1,  sigma = 0.2","Brownian motion"), cex=0.8, #
   col=c("deepskyblue1","chartreuse2","coral1"), pch=1, lty=1);
maturity <- 15#
simulation.length <- 10001#
dt <-  maturity/(simulation.length-1)#
#
timeline <- seq(0,maturity, dt)#
#
S0<-1#
r<-0.05#
mu<-0.1#
mu0<-0.2#
sigma<-0.1#
sigma0<-0.1#
#
f <- g <- g0 <- h <- h0 <- rep(0, times=simulation.length)#
g0[1] <- h0[1] <- g[1] <-  h[1] <- S0#
#
for(i in 2:simulation.length){#
 f[i] <- f[i-1]+sqrt(dt)*rnorm(1)#
 g[i] <- g[1]*exp((mu-(sigma^2)/2)*(i-1)*dt+sigma*f[i])#
 g0[i] <- g0[1]*exp(mu*(i-1)*dt)#
 h[i] <- h[1]*exp((mu0-sigma0^2/2)*(i-1)*dt+sigma0*f[i])#
 h0[i] <- h0[1]*exp(mu0*(i-1)*dt)#
}#
#
o_range <- range(f,g,g0,h,h0)#
#
plot(timeline,f, ylim=o_range, type="l", col="coral1")#
lines(timeline,g0, col="chartreuse3")#
lines(timeline,g, col="chartreuse2")#
lines(timeline,h, col="deepskyblue1")#
lines(timeline,h0, col="deepskyblue3")#
#
title(main="Geometric Brownian Motion trajectories", col.main="red", font.main=4)#
legend(1, o_range[2], c("mu = 0.2,  sigma = 0.375","mu = 0.1,  sigma = 0.2","Brownian motion"), cex=0.8, #
   col=c("deepskyblue1","chartreuse2","coral1"), pch=1, lty=1);
require(ape)
require(geiger)
install.packages("Morpho")
require(Morpho)
mesh2mesh(~/Documents/kuehrow2ASCII.stl,~/Documents/interrow1.stl)
mesh2mesh("~/Documents/kuehrow2ASCII.stl","~/Documents/interrow1.stl")
mesh2mesh("~/Downloads/UCMP212459_33-4.obj","~/Downloads/UCMP216157_43-4.obj")
mesh2mesh("~/Downloads/UCMP212459_33-4.obj","~/Downloads/UCMP216157_43-4.obj", clean=F)
rgl.spheres(3,3,3,3)
rgl.surface(3,3,3)
rgl.surface(3,3)
rgl.surface(3,2,3)
rgl.surface(3,c(1,2),3)
?Morph
?Morpho
require(Morpho)
data(nose)##load data#
##warp a mesh onto another landmark configuration:#
warpnose.long <- warp.mesh(shortnose.mesh,shortnose.lm,longnose.lm)#
shade3d(warpnose.long,col=skin1)
head(shortnose.mesh)
setwd("/Users/Home/Dropbox/Amherst/Courses/SOURCE/R-Meet/Ants")
read.table("antAb.txt",header=T)->antAb#
read.table("antHead.txt",header=T)->antHead
centerX=rep(NA,nrow(antAb))#
centerY=centerX#
#
#ENTER THE FOR LOOP#
for(i in 1:length(centerX)){#
  tempx=(antAb$X[i] + antHead$X[i])/2#
  tempy=-(antAb$Y[i] + antHead$Y[i])/2#
  centerX[i]=tempx#
  centerY[i]=tempy#
}#
#
#transformation to start at 0#
centerY=centerY-centerY[1]#
centerX=centerX-centerX[1]#
#
plot(x=centerX,y=centerY,type="l")
plot(x=centerX,y=centerY,type="b")
centerX=rep(NA,nrow(antAb))
centerX
centerY=centerX
centerY
setwd("/Users/Home/Dropbox/Amherst/Courses/SOURCE/2013-Fall/R-Meet-Up")#
#
#Using interactivity and reading in data.#
MakeFiles<-function(){#
importData=function(){ #interactive#
  print(list.files())#
  dataIndex<-as.numeric(readline("What index value is your dataset? \n"))#
  as.matrix(read.table(list.files()[dataIndex], header=T, row.names=1, na.strings="NA", sep=","))#
}#
#
DataFile<-importData()#
#
}
MakeFiles()
DataFile
MyData<-MakeFiles()
MyData
setwd("/Users/Home/Dropbox/Amherst/Courses/SOURCE/2013-Fall/R-Meet-Up")#
#
#Using interactivity and reading in data.#
MakeFiles<-function(){#
importData=function(){ #interactive#
  print(list.files())#
  dataIndex<-as.numeric(readline("What index value is your dataset? \n"))#
  as.matrix(read.csv(list.files()[dataIndex], header=T, row.names=1, na.strings="?",))#
}#
#
DataFile<-importData()#
#
}#
#
MyData<-MakeFiles()
MyData
str(MyData)
Test<-read.csv("anolisData.csv")
Test
setwd("/Users/Home/Dropbox/Amherst/Courses/SOURCE/2013-Fall/R-Meet-Up")#
#
#Using interactivity and reading in data.#
MakeFiles<-function(){#
importData=function(){ #interactive#
  print(list.files())#
  dataIndex<-as.numeric(readline("What index value is your dataset? \n"))#
  as.matrix(read.csv(list.files()[dataIndex], header=T, row.names=1, na.strings="?"))#
}#
#
DataFile<-importData()#
#
}#
#
MyData<-MakeFiles()
MyData
setwd("/Users/Home/Dropbox/Amherst/Courses/SOURCE/2013-Fall/R-Meet-Up")#
#
#Using interactivity and reading in data.#
MakeFiles<-function(){#
importData=function(){ #interactive#
  print(list.files())#
  dataIndex<-as.numeric(readline("What index value is your dataset? \n"))#
  read.csv(list.files()[dataIndex], header=T, row.names=1, na.strings="?")#
}#
#
DataFile<-importData()#
#
}#
#
MyData<-MakeFiles()
MyData
setwd("/Users/Home/Dropbox/Amherst/Courses/SOURCE/2013-Fall/R-Meet-Up")#
#
#Using interactivity and reading in data.#
MakeFiles<-function(){#
importData=function(){ #interactive#
  print(list.files())#
  dataIndex<-as.numeric(readline("What index value is your dataset? \n"))#
  read.csv(list.files()[dataIndex], header=T, row.names=1, na.strings="?")#
}#
#
DataFile<-importData()#
#
Test<-apply(DataFile,2,mean)#
#
Final<-list(DataFile,Test)#
Final#
}#
#
MyData<-MakeFiles()
setwd("/Users/Home/Dropbox/Amherst/Courses/SOURCE/2013-Fall/R-Meet-Up")#
#
#Using interactivity and reading in data.#
MakeFiles<-function(){#
importData=function(){ #interactive#
  print(list.files())#
  dataIndex<-as.numeric(readline("What index value is your dataset? \n"))#
  read.csv(list.files()[dataIndex], header=T, row.names=1, na.strings="?")#
}#
#
DataFile<-importData()#
#
Test<-apply(DataFile,2,mean, na.rm=T)#
#
Final<-list(DataFile,Test)#
Final#
}#
#
MyData<-MakeFiles()
Testing<-read.csv("anolisData.csv")#
#
Final<-apply(Testing,2,mean, na.rm=T)
warnings()
Testing
setwd("/Users/Home/Dropbox/Amherst/Courses/SOURCE/2013-Fall/R-Meet-Up")#
#
#Using interactivity and reading in data.#
MakeFiles<-function(startcol,endcol){#
importData=function(){ #interactive#
  print(list.files())#
  dataIndex<-as.numeric(readline("What index value is your dataset? \n"))#
  read.csv(list.files()[dataIndex], header=T, row.names=1, na.strings="?")#
}#
#
DataFile<-importData()#
#
Test<-apply(DataFile[,startcol: endcol],2,mean, na.rm=T)#
#
Final<-list(DataFile,Test)#
Final#
}#
#
MyData<-MakeFiles(3,5)
MyData
iDemandPi<-function(n=100){#
#Two runs will give you your x and y coordinate position#
randomX<-runif(n=n, min=-1, max=1)#
randomY<-runif(n=n, min=-1, max=1)#
#
#To get ourt circle part, x^2+y^2=1, and also values less than one will be within the circle#
insideCircle<-randomX^2+randomY^2<=1#
#Want to get # points in circle/# points in square * 4 (area of square)#
#Divide by n (all numbers) as all numbers will be somewhere within the square.#
#R reads TRUE and FALSE statements as 1 and 0.#
myPi=4*(sum(insideCircle)/n)#
#
#Now index by the logical statement.#
plot(x=randomX[insideCircle], y=randomY[insideCircle], pch=19)#
return(myPi)#
}#
#
iDemandPi(1000)
randomX<-runif(n=100, min=-1, max=1)#
randomY<-runif(n=100, min=-1, max=1)
randomX
randomY
insideCircle<-randomX^2+randomY^2<=1
insideCircle
insideCircle<-randomX^2+randomY^2
insideCircle
Top<-seq(1:10)
Top
Bottom<-Top
Bottom
Tables<-matrix(data=NA,ncol=length(Top), nrow=length(Bottom))
Tables
Top<-seq(1:10)#
Bottom<-Top#
#
Tables<-matrix(data=NA,ncol=length(Top), nrow=length(Bottom))#
#
for(i in 1:length(Top)){#
#
	for(j in 1:length(Bottom)){#
		Tables[i,j]<-i*j#
	}	#
}
Tables
TimesTables<-function(n=100){#
#
First<-seq(1:n)#
Second<-First#
#
Tables<-matrix(data=NA,ncol=length(First), nrow=length(Second))#
#
for(i in 1:length(First)){#
#
	for(j in 1:length(Second)){#
		Tables[i,j]<-i*j#
	}	#
	Tables#
}#
}
TimesTables()
TimesTables
TimesTables()
TTs<-TimesTables()
TTs
TimesTables<-function(n=100){#
#
First<-seq(1:n)#
Second<-First#
#
Tables<-matrix(data=NA,ncol=length(First), nrow=length(Second))#
#
for(i in 1:length(First)){#
#
	for(j in 1:length(Second)){#
		Tables[i,j]<-i*j#
	}	#
	return(Tables)#
}#
}
TimesTables()
First<-seq(1:10)#
Second<-First
Tables<-matrix(data=NA, ncol=length(First), nrow=length(Second))
for(i in 1:length(First)){#
#
	for(j in 1:length(Second)){#
		Tables[i,j]<-i*j#
	}	#
	return(Tables)#
}
for(i in 1:length(First)){#
#
	for(j in 1:length(Second)){#
		Tables[i,j]<-i*j#
	}	#
	Tables#
}
Tables
TimesTables<-function(n=10){#
#
First<-seq(1:n)#
Second<-First#
#
Tables<-matrix(data=NA, ncol=length(First), nrow=length(Second))#
#
for(i in 1:length(First)){#
#
	for(j in 1:length(Second)){#
		Tables[i,j]<-i*j#
	}	#
}#
print(Tables)#
}
TimesTables(100)
